using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.Extensions.Logging;
using RunThis.Core.Invoker;

namespace RunThis.Core.Directory
{


    public interface IInvokerDirectory
    {
        T AsAddress<T>(T target);
        bool Remove<T>(T target);
    }
    public class InvokerDirectory : IInvokerDirectory
    {
        class InvokerContext
        {
            public InvokerContext(object proxy)
            {
                Proxy = proxy;
            }

            public object Proxy { get; private set; }
        }

        private readonly ConcurrentDictionary<object, InvokerContext> _contexts;
        private readonly ILogger<InvokerDirectory> _logger;

        public InvokerDirectory(ILogger<InvokerDirectory> logger)
        {
            _contexts = new ConcurrentDictionary<object, InvokerContext>();
            _logger = logger;
        }

        static class ProxyCache<T>
        {
            static Func<T> _proxyFactory;
            static object _lockObject;

            static ProxyCache()
            {
                _lockObject = new object();
            }
            internal static T CreateProxy(T target, IInvoker invoker, ILogger logger)
            {
                if (_proxyFactory == null)
                    lock (_lockObject)
                        if (_proxyFactory == null)
                            _proxyFactory = CreateProxyFactory(target, invoker, logger);

                return _proxyFactory();
            }

            private static Func<T> CreateProxyFactory(T target, IInvoker invoker, ILogger logger)
            {
                //var source = CreateProxyCode<T>();

                if (!TryCompileType(code, logger, out var proxyType, out var message))
                    throw new Exception(message);

                return () => (T)Activator.CreateInstance(proxyType, target, invoker);
            }


            static string template = @"
using System.Threading.Tasks;
using RunThis.Core.Invoker;

namespace RunThis.Autogenerated.Proxy
{{
    //TName: {0}
    //TFullName: {1}
    public class {0}Proxy : {1}
    {{
        private readonly {0} _target;
        private readonly IInvoker _invoker;


        public FighterProxy1({0} target, IInvoker invoker)
        {{
            _target = target;
            _invoker = invoker;
        }}        
    }}
}}
            ";

            private static string CreateProxyCode<T1>()
            {
                return string.Format(template, typeof(T).Name, typeof(T).FullName);
            }

            private static bool TryCompileType(string source, ILogger logger, out Type type, out string message)
            {
                message = "";
                type = null;
                logger?.LogInformation("Parsing the code into the SyntaxTree");

                SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source);

                string assemblyName = Path.GetRandomFileName();

                var trustedAssembliesPaths = ((string)AppContext.GetData("TRUSTED_PLATFORM_ASSEMBLIES")).Split(Path.PathSeparator);

                //MetadataReference[] references = trustedAssembliesPaths.Select(r => MetadataReference.CreateFromFile(r)).ToArray();

                var refPaths = new[] {
                    typeof(object).GetTypeInfo().Assembly.Location,
                    typeof(T).GetTypeInfo().Assembly.Location,
                    typeof(ProxyCache<T>).GetTypeInfo().Assembly.Location,
                    Path.Combine(Path.GetDirectoryName(typeof(System.Runtime.GCSettings).GetTypeInfo().Assembly.Location), "System.Runtime.dll")
                };

                MetadataReference[] references = refPaths
                    .Concat(trustedAssembliesPaths.Where(x => x.Contains("netstandard")))
                    .Select(r => MetadataReference.CreateFromFile(r))
                    .ToArray();

                logger?.LogInformation("Adding the following references");
                foreach (var r in refPaths)
                    logger?.LogInformation(r);

                logger?.LogInformation("Compiling ...");

                CSharpCompilation compilation = CSharpCompilation.Create(
                    assemblyName,
                    syntaxTrees: new[] { syntaxTree },
                    references: references,
                    options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, optimizationLevel: OptimizationLevel.Release));

                using (var ms = new MemoryStream())
                {
                    EmitResult result = compilation.Emit(ms);

                    if (!result.Success)
                    {
                        logger?.LogError("Compilation failed!");
                        IEnumerable<Diagnostic> failures = result.Diagnostics.Where(diagnostic =>
                            diagnostic.IsWarningAsError ||
                            diagnostic.Severity == DiagnosticSeverity.Error);

                        foreach (Diagnostic diagnostic in failures)
                            message += $"{diagnostic.Id}: {diagnostic.GetMessage()}\n";                       
                        
                        return false;
                    }
                    else
                    {
                        logger?.LogInformation("Compilation successful! Now instantiating and executing the code ...");
                        ms.Seek(0, SeekOrigin.Begin);

                        Assembly assembly = AssemblyLoadContext.Default.LoadFromStream(ms);
                        type = assembly.GetType("RunThis.Tests.Targets1.FighterProxy1");
                        return true;
                    }
                }
            }

            static string code = @"
using System.Threading.Tasks;
using RunThis.Core.Invoker;
using RunThis.Tests.Targets;

namespace RunThis.Tests.Targets1
{
    public class FighterProxy1 : IFighter
    {
        private readonly IFighter _target;
        private readonly IInvoker _invoker;


        public FighterProxy1(IFighter target, IInvoker invoker)
        {
            _target = target;
            _invoker = invoker;
        }

        readonly struct GetReadyCall : ICall
        {
            private readonly IFighter _target;
            public GetReadyCall(IFighter target) => _target = target;
            public ValueTask Invoke() => _target.GetReady();
        }

        readonly struct GetRemainingHealthCall : ICall<int>
        {
            private readonly IFighter _target;
            public GetRemainingHealthCall(IFighter target) => _target = target;
            public ValueTask<int> Invoke() => _target.GetRemainingHealth();
        }

        readonly struct TakeDamageCall : ICall
        {
            private readonly IFighter _target;
            private readonly int _value;

            public TakeDamageCall(IFighter target, int value)
            {
                _target = target;
                _value = value;
            }

            public ValueTask Invoke() => _target.TakeDamage(_value);
        }

        public ValueTask GetReady()
        {
            return _invoker.ExecuteVoidCall(new GetReadyCall(_target));
        }

        public ValueTask<int> GetRemainingHealth()
        {
            return _invoker.ExecuteValueCall(new GetRemainingHealthCall(_target));
        }

        public ValueTask TakeDamage(int value)
        {
            return _invoker.ExecuteVoidCall(new TakeDamageCall(_target, value));
        }   
    }
}
            ";

        }

        private InvokerContext CreateContext<T>(T target, ILogger logger)
        {
            return new InvokerContext(ProxyCache<T>.CreateProxy(target, new SingleThreadInvoker(), logger));
        }

        public T AsAddress<T>(T target)
        {
            var context = _contexts.GetOrAdd(target, CreateContext(target, _logger));
            return (T)context.Proxy;
        }

        public bool Remove<T>(T target)
        {
            return _contexts.TryRemove(target, out _);
        }

    }
}
